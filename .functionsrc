it2prof() {
  echo -e "\033]50;SetProfile=$1\a"
};

# Display directory contents after cd.
function c() {
  builtin cd "$@" && ls -F
}

function fu_command_line() {
  https://www.commandlinefu.com/commands/matching/space/c3BhY2U=/sort-by-votes
}

function git_create_new_repo() {
  curl -u $1 https://api.github.com/user/repos -d '{"name": '$2', "private": "true"}'
}

function octalf() {
  stat -f '%A %a %n' $1
}

# get the 20 most used commands
# https://github.com/trimstray/the-book-of-secret-knowledge#tool-terminal
function hist() {
  history |
    awk '''
    {
      CMD[$2]++;
      count++;
    }
    END
    {
      for (a in CMD)
        print CMD[a] " " CMD[a]/count * 100 "% " a;
    }
  ''' | grep -v "./" | column -c -s ' ' -t | sort -nr | nl | head -n 20
  # note that line 16 will ruin everything if u break it up over multiple lines
}

function shce() {
  # Read  commands  but  do  not execute them.  This may be
  # used to check a shell script for syntax  errors.   This
  # is ignored by interactive shells.
  bash -n
}

# kill process running on port <port>
# use node_module :) kp
# kill_port() {
#   # kill -9 $(lsof -i :<port> | awk `{l=$2} END {print l}`)
# }

# find last reboot time
function who_boot() {
  who -b
}

# show 20 biggest directories with K M G
function biggest_loosers() {
  du |
    sort -r -n |
    awk '{split("K M G",v); s=1; while($1>1024){$1/=1024; s++} print int($1)" "v[s]"\t"$2}' |
    head -n 20
}

# add note
function n() {
  echo "${*}" >>~/notes.md
  echo "noted"
}

# add todo
function td() {
  echo "${*}" >>~/todo.md
  cat ~/todo.md
}

# howdoi
function hdi() {
  howdoi "$*" -a -c -n 3
}

function rmd() {
  pandoc "$1" | lynx -stdin
}

function pman() {
  man -t "${@}" | open -f -a /Applications/Preview.app/
}

function hman() {
  groff -Thtml -man $(man -w ${@}) >/tmp/hman$$.html
  open /tmp/hman$$.html
}

function dud() {
  du |
    sort -r -n |
    awk '{ split("K M G",v);
        s=1;
        while ($1>1024) {
          $1/=1024; s++
        }
        print int($1) " " v[s] "\t" $2
      }' |
    head -n 20
}

sync_and_deploy_dot_files() {
  cd /Users/tyler/totfiles && git pull git add .  && git commit -m "stdout" && git push
}

# performance timing
# function performance() {
#   for i in $(seq 1 10); do /usr/bin/time zsh -i -c exit; done
# 
# # Create a new directory and enter it
# function mkd() {
# 	mkdir -p "$@" && cd "$_";
# }
# 
# # Change working directory to the top-most Finder window location
# function cdf() { # short for `cdfinder`
# 	cd "$(osascript -e 'tell app "Finder" to POSIX path of (insertion location as alias)')";
# }
# 
# # Create a .tar.gz archive, using `zopfli`, `pigz` or `gzip` for compression
# function targz() {
# 	local tmpFile="${@%/}.tar";
# 	tar -cvf "${tmpFile}" --exclude=".DS_Store" "${@}" || return 1;
# 
# 	size=$(
# 		stat -f"%z" "${tmpFile}" 2> /dev/null; # macOS `stat`
# 		stat -c"%s" "${tmpFile}" 2> /dev/null;  # GNU `stat`
# 	);
# 
# 	local cmd="";
# 	if (( size < 52428800 )) && hash zopfli 2> /dev/null; then
# 		# the .tar file is smaller than 50 MB and Zopfli is available; use it
# 		cmd="zopfli";
# 	else
# 		if hash pigz 2> /dev/null; then
# 			cmd="pigz";
# 		else
# 			cmd="gzip";
# 		fi;
# 	fi;
# 
# 	echo "Compressing .tar ($((size / 1000)) kB) using \`${cmd}\`…";
# 	"${cmd}" -v "${tmpFile}" || return 1;
# 	[ -f "${tmpFile}" ] && rm "${tmpFile}";
# 
# 	zippedSize=$(
# 		stat -f"%z" "${tmpFile}.gz" 2> /dev/null; # macOS `stat`
# 		stat -c"%s" "${tmpFile}.gz" 2> /dev/null; # GNU `stat`
# 	);
# 
# 	echo "${tmpFile}.gz ($((zippedSize / 1000)) kB) created successfully.";
# }
# 
# # Determine size of a file or total size of a directory
# function fs() {
# 	if du -b /dev/null > /dev/null 2>&1; then
# 		local arg=-sbh;
# 	else
# 		local arg=-sh;
# 	fi
# 	if [[ -n "$@" ]]; then
# 		du $arg -- "$@";
# 	else
# 		du $arg .[^.]* ./*;
# 	fi;
# }
# 
# # Use Git’s colored diff when available
# hash git &>/dev/null;
# if [ $? -eq 0 ]; then
# 	function diff() {
# 		git diff --no-index --color-words "$@";
# 	}
# fi;
# 
# # Create a data URL from a file
# function dataurl() {
# 	local mimeType=$(file -b --mime-type "$1");
# 	if [[ $mimeType == text/* ]]; then
# 		mimeType="${mimeType};charset=utf-8";
# 	fi
# 	echo "data:${mimeType};base64,$(openssl base64 -in "$1" | tr -d '\n')";
# }
# 
# # Start an HTTP server from a directory, optionally specifying the port
# function server() {
# 	local port="${1:-8000}";
# 	sleep 1 && open "http://localhost:${port}/" &
# 	# Set the default Content-Type to `text/plain` instead of `application/octet-stream`
# 	# And serve everything as UTF-8 (although not technically correct, this doesn’t break anything for binary files)
# 	python -c $'import SimpleHTTPServer;\nmap = SimpleHTTPServer.SimpleHTTPRequestHandler.extensions_map;\nmap[""] = "text/plain";\nfor key, value in map.items():\n\tmap[key] = value + ";charset=UTF-8";\nSimpleHTTPServer.test();' "$port";
# }
# 
# # Start a PHP server from a directory, optionally specifying the port
# # (Requires PHP 5.4.0+.)
# function phpserver() {
# 	local port="${1:-4000}";
# 	local ip=$(ipconfig getifaddr en1);
# 	sleep 1 && open "http://${ip}:${port}/" &
# 	php -S "${ip}:${port}";
# }
# 
# # Compare original and gzipped file size
# function gz() {
# 	local origsize=$(wc -c < "$1");
# 	local gzipsize=$(gzip -c "$1" | wc -c);
# 	local ratio=$(echo "$gzipsize * 100 / $origsize" | bc -l);
# 	printf "orig: %d bytes\n" "$origsize";
# 	printf "gzip: %d bytes (%2.2f%%)\n" "$gzipsize" "$ratio";
# }
# 
# # Run `dig` and display the most useful info
# function digga() {
# 	dig +nocmd "$1" any +multiline +noall +answer;
# }
# 
# # Show all the names (CNs and SANs) listed in the SSL certificate
# # for a given domain
# function getcertnames() {
# 	if [ -z "${1}" ]; then
# 		echo "ERROR: No domain specified.";
# 		return 1;
# 	fi;
# 
# 	local domain="${1}";
# 	echo "Testing ${domain}…";
# 	echo ""; # newline
# 
# 	local tmp=$(echo -e "GET / HTTP/1.0\nEOT" \
# 		| openssl s_client -connect "${domain}:443" -servername "${domain}" 2>&1);
# 
# 	if [[ "${tmp}" = *"-----BEGIN CERTIFICATE-----"* ]]; then
# 		local certText=$(echo "${tmp}" \
# 			| openssl x509 -text -certopt "no_aux, no_header, no_issuer, no_pubkey, \
# 			no_serial, no_sigdump, no_signame, no_validity, no_version");
# 		echo "Common Name:";
# 		echo ""; # newline
# 		echo "${certText}" | grep "Subject:" | sed -e "s/^.*CN=//" | sed -e "s/\/emailAddress=.*//";
# 		echo ""; # newline
# 		echo "Subject Alternative Name(s):";
# 		echo ""; # newline
# 		echo "${certText}" | grep -A 1 "Subject Alternative Name:" \
# 			| sed -e "2s/DNS://g" -e "s/ //g" | tr "," "\n" | tail -n +2;
# 		return 0;
# 	else
# 		echo "ERROR: Certificate not found.";
# 		return 1;
# 	fi;
# }
# 
# # Normalize `open` across Linux, macOS, and Windows.
# # This is needed to make the `o` function (see below) cross-platform.
# if [ ! $(uname -s) = 'Darwin' ]; then
# 	if grep -q Microsoft /proc/version; then
# 		# Ubuntu on Windows using the Linux subsystem
# 		alias open='explorer.exe';
# 	else
# 		alias open='xdg-open';
# 	fi
# fi
# 
# # `o` with no arguments opens the current directory, otherwise opens the given
# # location
# function o() {
# 	if [ $# -eq 0 ]; then
# 		open .;
# 	else
# 		open "$@";
# 	fi;
# }

# `tre` is a shorthand for `tree` with hidden files and color enabled, ignoring
# the `.git` directory, listing directories first. The output gets piped into
# `less` with options to preserve color and line numbers, unless the output is
# small enough for one screen.
# function tre() {
# 	tree -aC -I '.git|node_modules|bower_components' --dirsfirst "$@" | less -FRNX;
# }
